--- ---------------------
--- Sequent Systems

--- ---------------------

***(
    This file contains 2 modules:
    - SEQUENT: containing the needed sorts and operations to build
    sequents of the object logic. This module must be extended with
    the inference rules of the object logic. For LaTeX outputs, an
    equation for TEXReplacementSeq must be defined mapping the name of
    the rules of the theory into LaTex commands. For instance
    eq TEXReplacementSeq = ('AndL |- '\wedge_L)

    - SEQUENT-SOLVING: utilities to build derivations and produce LaTeX
    outputs.
   )

--- ----------------------
--- Modifications Jan 2021
--- ----------------------
--- * Adding support for linear nested systems (LNS):
---   - New sort LNS and constructors
---   - updating the procedures to support LaTeX output of LNSs
---   - Previous Sort Sequent becomes SSequent (Simple-Sequent)
---   - The sort Sequent now is the supersort including Simple Sequents
---     and LNS

load syntax .

fmod SEQUENT is
  pr SYNTAX-BASE .
  pr NAT-INF .
  sort SSequent . --- Simple sequents 
  sort Sequent .
  subsort SSequent < Sequent .

  --- Constructor for sequents .
  --- two sided
  op _|--_ : MSFormula MSFormula -> SSequent [ctor prec 90] .
  --- one sided
  op |--_ : MSFormula -> SSequent [ctor prec 90] .
  op _:_ : INat Sequent -> Sequent [ctor prec 100] .
  op error : -> Sequent [ctor] .

  --- Linear Nested Sequents
  sort LNS .
  subsort SSequent < LNS < Sequent .

  --- Empty LNS
  op EPS : -> LNS [ctor] .

  --- Building lists of sequents
  --- snoc style is used (no associativity to avoid problems with unification)

  op _//_ : LNS SSequent -> LNS [ctor left id: EPS prec 110] .


  --- Goals to be proved (list of sequents)
  sort Goal .
  subsort Sequent < Goal .
  op proved : -> Goal [ctor] .
  op _|_ : Goal Goal -> Goal [frozen(2) id: proved] .
  op error : -> Goal [ctor] .

  --- Mapping from rule'names into LaTex code (to be implemented in
      --- the OL)
  op TEXReplacementSeq : -> Map{Qid, Qid} .

endfm

  --- The main functionality of this module is to produce a LaTeX output
  --- from the trace generated by metaSearch when trying to prove a
  --- given goal. For each step in the trace, we build a tree and, in
  --- the end, the tree is translated into a string.
mod SEQUENT-SOLVING is
  pr SEQUENT .
  pr IO-EXT .

  --------------------------------------
  vars S S'             : SSequent .
  vars LNS1 LNS2        : Sequent .
  var Ans               : Trace? .
  vars T T' T''         : Term .
  vars Ty Ty'           : Type .
  vars Sb               : Substitution .
  vars Lim              : INat .
  vars Tr Tr'           : Trace .
  var Ts                : TraceStep .
  vars R R'             : Rule .
  vars LS12 LS LS'      : Goal .
  var RName             : Qid .
  vars n n'             : Nat .
  vars Q Q'             : Qid .
  vars G G'             : Goal .
  vars k k'             : INat .
  var M                 : Module .
  vars str str'         : String .
  var LQid              : QidList .
  vars vat vat' vat''   : ATree .
  vars vlat vlat'       : ALTree .
  vars GT GT'           : GroundTerm .
  vars Gamma Delta      : MSFormula .
  var QKind             : [Qid] .
  var map               : Map{Qid, Qid} .
  --------------------------------------

  --- Generating a LaTex String from the meta-representation of a
  --- sequent
  op toTexSAbs : Module Term -> String .
  ceq toTexSAbs(M, T) =
        printTokens(replaceTex(LQid,
            downTerm(getTerm(metaReduce(M, upTerm(TEXReplacement))), empty)
            ))
  if LQid := metaPrettyPrint(M, T, number mixfix) .

  --- Returning the name of the rule (with possible replacements due to TEXReplacementSeq)
  --- Here we also delete the predix "INF" (added to the name of
  --- the rules when no inductive measures are considered
  op ruleName :  Module Qid -> Qid .
  op replace : Qid Map{Qid, Qid} -> Qid .
  eq replace(Q, ( ( Q |-> Q'), map)) = Q' .
  eq replace(Q, map) = Q [owise] .
  eq ruleName(M, Q)
  = replace(
    if startsWith(Q, "INF") then substr(Q,3) else Q fi,
    downTerm(getTerm(metaReduce(M, upTerm(TEXReplacementSeq))), empty)) .

  --- Term denoting error
  op error : -> Term .
  eq error = 'error.Goal .

  --- Attribute to mark rules without inductive measure ('inf.INat)
  op rinf : -> Attr [ctor] .

  --- -------------------------------------------------------
  --- Trees: leaves and nodes
  --- -------------------------------------------------------
  --- Initially, the tree is AL(T) where T is a (meta-level)
  --- Term. Such leave is replaced with AT(str, rname, list-tree)
  --- where str is the string representing T, rname the name of the
  --- rule used and list-tree the resulting premises.
  sorts ATree ALTree .
  subsort ATree < ALTree .
  --- leafs. 
  op AL : Term -> ATree . 
  op AL : String Qid -> ATree . 
  op AL : String -> ATree .
  --- Nodes. 
  op AT : String Qid ALTree -> ATree .
  --- list of trees
  op _,_ : ALTree ALTree -> ALTree [ctor prec 70 assoc id: Aemp] .
  op Aemp : -> ALTree [ctor] .
  --- Errors for the meta-level
  op Aerror : -> ATree [ctor] .


  --- Given a goal, it produces an string with the LaTex code of the
  --- derivation
  op output : Module Goal -> String .
  eq output(M, G) =
  output(M,  metaSearchPath(M, upTerm(G), upTerm(proved), nil, '*, unbounded, 0)) . 
  op output : Module Trace -> String .
  eq output(M, Tr) = toTex(buildTree(M, Tr)) .

  --- Saving the output into a file
  op save : Module Goal String -> Configuration .
  --- str is the file name
  eq save(M, G, str) = write(output(M, G), str, "a+") .

  --- Building the tree for the trace
  op buildTree : Module Trace -> ATree .
  eq buildTree(M, {T, Ty, R} Tr ) = buildTree(M, {T, Ty, R} Tr, AL(T)) .
  op buildTree : Module Trace ATree -> ATree .

  --- The last step in the proof. The current goal is simply deleted
  eq buildTree(M,  {T, Ty, R} , vat)
  = update(M, vat, AL(T), AL(toTexSAbs(M,T), ruleName(M, getName(R)))) .

  eq buildTree(M,  {T, Ty, R} {T', Ty', R'} Tr , vat) =
  buildTree(M,  {T', Ty', R'} Tr , update(M, vat, T, T' , getName(R)) ) .


  --- Number of sequents in a list of sequents (seen as a term)
  op size : Module Term -> Nat .
  eq size(M, T) =
  if T == 'proved.Goal then 0 else count(metaPrettyPrint(M, T, none)) fi .
  --- Count the number of '_|_ in the list of Qids. (plus 1)
  op count : QidList -> Nat .
  eq count(nil) = 1 . --- We always assume that there is a sequent
  eq count(Q LQid) = if Q == '_|_ then s(count(LQid)) else count(LQid) fi .


  --- Take N elements from a list of (meta-level) sequents
  --- We assume rules to produce at most two premises
  op take : Term Nat -> Term .
  eq take('_:_[T, T'], 1) = '_:_[T, T'] .
  eq take('_|_[T, T'], 1) = take(T, 1) .
  eq take('_|_[T, T'], 2) = if isSequent(T) then '_|_[T, take(T',1)] else take(T,2) fi .

  --- Test if the term is a sequent or a list of sequents
  op isSequent : Term -> Bool .
  eq isSequent('_:_[T, T']) = true .
  eq isSequent(T) = false [owise] .

  --- From a list of meta-terms builds a list of leaves
  op leaves : Term -> ALTree .
  eq leaves('_:_[T, T']) = AL('_:_[T, T']) .
  eq leaves('_|_[T, T']) = leaves(T) , leaves(T') .

  --- Making the substitutions in the tree
  --- The 2 terms are list of abstract sequents
  var TS : Term .
  op update : Module ATree Term Term Qid -> ATree .
  ceq update(M, vat, T, T', RName) =
  --- a rule producing one or more premises
  (if n' >= n then
   update(M, vat , AL(TS), AT(toTexSAbs(M,TS), ruleName(M, RName), leaves(take(T', 1 + sd(n', n)))))
   else update(M, vat, AL(TS), AL(toTexSAbs(M,TS), ruleName(M, RName)))
   fi )
  if  n := size(M, T) /\ n' := size(M, T') /\ TS := take(T,1) .

  op update : Module ATree ATree ATree -> ATree .
  --- Substitutes in vat the ocurrences of vat' with vat''
  eq update(M, vat, vat', vat'') = 
  downTerm( getTerm( metaRewrite(project(M, (rl upTerm(vat') => upTerm(vat'') [none]. ) ), upTerm(vat), 1 )) ,  Aerror) .

  op toTex :  ATree -> String .
  op toTexL : ALTree -> String .
  eq toTex(Aerror) = "\errorTK" .

  eq toTex(AL(str)) = "\\deduce{" + str + "}{}" .
  eq toTex(AL(str,RName)) = "\\infer[" + string((RName)) + "]{" + str + "}{}" .
  eq toTex(AT(str,RName, vlat)) = "\\infer[" + string((RName)) + "]{" + str + "}{" + toTexL(vlat) + "}" .


  eq toTexL(Aemp) = "" .
  eq toTexL((vat , vlat) ) = toTex(vat) + 
  if vlat == Aemp then "" else " & " + toTexL(vlat) fi .

  --- Auxiliary functions for printing

  --- outputs the string resulting from G ; {P1, P2 ... } where Pi are the premises
  op string : Module Qid GroundTerm GroundTerm -> String .
  eq string(M, Q , GT, GT') = toTex(
      AT(toTexSAbs(M, GT), ruleName(M,Q), leaves(M, GT'))) .

  op string-fail : Module GroundTerm -> String .
  eq string-fail(M, GT) =
  "\\textcolor{red}{" + toTex(AL(toTexSAbs(M,GT), '\failTK))+ "}" .

  --- From a list of meta-terms builds a list of leaves
  --- This is to print the premises (considered as axioms)
  op leaves : Module Term -> ALTree .
  eq leaves(M, '_:_[T, T']) = AL(toTexSAbs(M, '_:_[T, T'])) .
  eq leaves(M, '_|_[T, T']) = leaves(M, T) , leaves(M, T') .
  eq leaves(M,T) = Aemp [owise] .
endm
